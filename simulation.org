* Generate Simulation Data

#+BEGIN_SRC R :tangle generateSyntheticData.r
  
  logit = function(input)
  {
      return( log(input / (1 - input) ) )
  }


  invlogit = function(x)
  {
      return( 1 / (1 + exp(-x)) )
  }

  
  ### Year Specific Bias
  simData.ysb = function(theta0 = .9, drift, Y.present, NSU.present, realData, pi = .05, p = .4)
  {
      numSites = dim(Y.present)[1]
      numLists = dim(Y.present)[2]
      numYears = dim(Y.present)[3]

      theta = theta0 + drift*(0:(numYears-1))

      fakeData = list("R" = realData$R,
                      "NSU.se" = realData$NSU.se,
                      "n" = realData$n)
      
      N = matrix(rbinom(n = numSites*numYears, size = fakeData$R, prob = pi), nrow = numSites, ncol = numYears)

      suppressWarnings({NSU = exp(matrix(rnorm(n = numSites*numYears, mean = log(N), sd = fakeData$NSU.se^2/N^2),
                     , nrow = numSites, ncol = numYears))})

      fakeData$NSU = NSU
      
      Y = array(NA, dim = c(numSites,numLists,numYears) )
      phat = array(NA, dim = c(numSites,numLists,numYears) )
      
      for(i in 1:numLists)
      {
          Y[,i,] = matrix(rbinom(n = numSites*numYears, size = N, prob = p),
                          nrow = numSites,
                          ncol = numYears)

          phat[,i,] = matrix(rnorm(n = numSites*numYears, mean = logit(p), sd = .3),
                          nrow = numSites,
                          ncol = numYears)

          theta.matrix = matrix(theta, nrow = numSites, ncol = numYears, byrow = TRUE)

          phat[,i,] = invlogit(phat[,i,] + theta.matrix)
      }

      Y[!Y.present] = NA
      phat[!Y.present] = NA
      
      fakeData$Y = Y
      fakeData$phat = phat

      return(fakeData)
  }

  
  ### Y is actually biased
  simData.Ybias = function(percentBias, Y.present, NSU.present, realData, pi = .05, p = .4)
  {
      numSites = dim(Y.present)[1]
      numLists = dim(Y.present)[2]
      numYears = dim(Y.present)[3]

      fakeData = list("R" = realData$R,
                      "NSU.se" = realData$NSU.se,
                      "n" = realData$n)
      
      N = matrix(rbinom(n = numSites*numYears, size = fakeData$R, prob = pi), nrow = numSites, ncol = numYears)
      
      suppressWarnings({NSU = exp(matrix(rnorm(n = numSites*numYears, mean = log(N), sd = fakeData$NSU.se^2/N^2),
                     , nrow = numSites, ncol = numYears))})

      fakeData$NSU = NSU
      
      Y = array(NA, dim = c(numSites,numLists,numYears) )
      phat = array(NA, dim = c(numSites,numLists,numYears) )
      
      for(i in 1:numLists)
      {
          Y[,i,] = matrix(rbinom(n = numSites*numYears, size = N, prob = p),
                          nrow = numSites,
                          ncol = numYears)

          Y[,i,] = ceiling(Y[,i,] + percentBias*Y[,i,])

          
          phat[,i,] = matrix(rnorm(n = numSites*numYears, mean = logit(p), sd = .3),
                          nrow = numSites,
                          ncol = numYears)

          phat[,i,] = invlogit(phat[,i,])
      }

      Y[!Y.present] = NA
      phat[!Y.present] = NA
      
      fakeData$Y = Y
      fakeData$phat = phat

      
      return(fakeData)
  }
  
#+END_SRC  


* Drift Simulations
#+BEGIN_SRC R :tangle drift.r

  setwd("/storage/work/j/jlp592/UkraineWithYearEffect")
  
  args <- commandArgs(trailingOnly = TRUE)
  drift = as.numeric(args[1])
  N = as.integer(args[2])
  N.MCMC = as.integer(args[3])

  source("LoadData.r")
  source("generateSyntheticData.r")
  source("/storage/home/jlp592/work/RevisedUkraine/MCMC2.r")
  
  length = N.MCMC
  thin = 50
  
  realData = LoadData()
  
  Y.present = !is.na(realData$Y) & !is.na(realData$phat)
  NSU.present = !is.na(realData$NSU)
  
  numSites = dim(Y.present)[1]
  numLists = dim(Y.present)[2]
  numYears = dim(Y.present)[3]

  
  current = list("alpha0" = 10,
                 "a0" = .05,#log(.5),
                 "beta0" = 10,
                 "b0" = 2,#log(6),
                 "alpha" = rep(10, numLists), 
                 "a" = rep(.5, numLists),
                 "beta" = rep(10, numLists),
                 "b" = rep(2, numLists),
                 "pi" = array(.05, dim = c(numSites, numYears)),
                 "sigmaPiSq" = .5,             
                 "N" = ceiling(array(realData$R*.05, dim = c(numSites, numYears) )),
                 "p" = array(.5, dim = c(numSites, numLists, numYears)),
                 "sigmaPSq" = .5,
                 "sigmaNSq" = array(1, dim = c(numSites, numYears)),
                 "tauSq" = 1,
                 "sigmaGammaSq" = .01,
                 "sigmaDeltaSq" = .01,
                 "sigmaESq" = .5,
                 "mu" = 0,
                 "theta" = .9,
                 "gamma" = rep(0, numLists), 
                 "delta" = rep(0, numSites),
                 "yearTrend" = rep(0, numYears),
                 "sigmaSq.yearTrend" = 0
                 )
  
  results = replicate(N, simData.ysb(theta0 = .9, drift = drift, Y.present, NSU.present, realData, pi = .05, p = .4), simplify = "list")

  for(i in 1:N)
  {
      data = results[,i]
      data$logit = logit(data$phat)
      
      chain = makeChain(data, length)
      
      ## Start Update Loop
      for(k in 1:(length*thin))
      {
          ## Update Chain
          current = update(current, data)
          
          ## Save Every thinth Iteration
          if( (k %% thin) == 0)
          {
              chain$"alpha0"[k/thin] = current$"alpha0"
              chain$"a0"[k/thin] = current$"a0"
              chain$"beta0"[k/thin] = current$"beta0"
              chain$"b0"[k/thin] = current$"b0"
              chain$"alpha"[k/thin,] = current$"alpha"
              chain$"a"[k/thin,] = current$"a"
              chain$"beta"[k/thin,] = current$"beta"
              chain$"b"[k/thin,] = current$"b"
              chain$"pi"[k/thin,,] = current$"pi"
              chain$"sigmaPiSq"[k/thin] = current$"sigmaPiSq"
              chain$"N"[k/thin,,] = current$"N"
              chain$"p"[k/thin,,,] = current$"p"
              chain$"sigmaPSq"[k/thin] = current$"sigmaPSq"
              chain$"sigmaNSq"[k/thin,,] = current$"sigmaNSq"
              chain$"sigmaGammaSq"[k/thin] = current$"sigmaGammaSq"
              chain$"sigmaDeltaSq"[k/thin] = current$"sigmaDeltaSq"
              chain$"sigmaESq"[k/thin] = current$"sigmaESq"
              chain$"mu"[k/thin] = current$"mu"
              chain$"theta"[k/thin] = current$"theta"
              chain$"gamma"[k/thin,] = current$"gamma"
              chain$"delta"[k/thin,] = current$"delta"
              chain$"yearTrend"[k/thin,] = current$"yearTrend"
              chain$"sigmaSq.yearTrend"[k/thin] = current$"sigmaSq.yearTrend"
              
              print(k/thin)
          }
      }

      save.image(file = paste("./Simulations/", drift , "-", i, ".RData", sep = "") )
  }

  
  
#+END_SRC

* Y Bias Simulations
#+BEGIN_SRC R :tangle ybias.r

  setwd("/storage/work/j/jlp592/UkraineWithYearEffect")
  
  args <- commandArgs(trailingOnly = TRUE)
  percentBias = as.numeric(args[1])
  N = as.integer(args[2])
  N.MCMC = as.integer(args[3])

  source("LoadData.r")
  source("generateSyntheticData.r")
  source("/storage/home/jlp592/work/RevisedUkraine/MCMC2.r")

  length = N.MCMC
  thin = 50
  
  realData = LoadData()
  
  Y.present = !is.na(realData$Y) & !is.na(realData$phat)
  NSU.present = !is.na(realData$NSU)

  numSites = dim(Y.present)[1]
  numLists = dim(Y.present)[2]
  numYears = dim(Y.present)[3]
  
  current = list("alpha0" = 10,
                 "a0" = .05,#log(.5),
                 "beta0" = 10,
                 "b0" = 2,#log(6),
                 "alpha" = rep(10, numLists), 
                 "a" = rep(.5, numLists),
                 "beta" = rep(10, numLists),
                 "b" = rep(2, numLists),
                 "pi" = array(.05, dim = c(numSites, numYears)),
                 "sigmaPiSq" = .5,             
                 "N" = ceiling(array(realData$R*.05, dim = c(numSites, numYears) )),
                 "p" = array(.5, dim = c(numSites, numLists, numYears)),
                 "sigmaPSq" = .5,
                 "sigmaNSq" = array(1, dim = c(numSites, numYears)),
                 "tauSq" = 1,
                 "sigmaGammaSq" = .01,
                 "sigmaDeltaSq" = .01,
                 "sigmaESq" = .5,
                 "mu" = 0,
                 "theta" = .9,
                 "gamma" = rep(0, numLists), 
                 "delta" = rep(0, numSites),
                 "yearTrend" = rep(0, numYears),
                 "sigmaSq.yearTrend" = 0
                 )

  results = replicate(N, simData.Ybias(percentBias, Y.present, NSU.present, realData, pi = .05, p = .4), simplify = "list")
  
  for(i in 1:N)
  {
      data = results[,i]
      data$logit = logit(data$phat)
      
      chain = makeChain(data, length)
      
      ## Start Update Loop
      for(k in 1:(length*thin))
      {
          ## Update Chain
          current = update(current, data)
          
          ## Save Every thinth Iteration
          if( (k %% thin) == 0)
          {
              chain$"alpha0"[k/thin] = current$"alpha0"
              chain$"a0"[k/thin] = current$"a0"
              chain$"beta0"[k/thin] = current$"beta0"
              chain$"b0"[k/thin] = current$"b0"
              chain$"alpha"[k/thin,] = current$"alpha"
              chain$"a"[k/thin,] = current$"a"
              chain$"beta"[k/thin,] = current$"beta"
              chain$"b"[k/thin,] = current$"b"
              chain$"pi"[k/thin,,] = current$"pi"
              chain$"sigmaPiSq"[k/thin] = current$"sigmaPiSq"
              chain$"N"[k/thin,,] = current$"N"
              chain$"p"[k/thin,,,] = current$"p"
              chain$"sigmaPSq"[k/thin] = current$"sigmaPSq"
              chain$"sigmaNSq"[k/thin,,] = current$"sigmaNSq"
              chain$"sigmaGammaSq"[k/thin] = current$"sigmaGammaSq"
              chain$"sigmaDeltaSq"[k/thin] = current$"sigmaDeltaSq"
              chain$"sigmaESq"[k/thin] = current$"sigmaESq"
              chain$"mu"[k/thin] = current$"mu"
              chain$"theta"[k/thin] = current$"theta"
              chain$"gamma"[k/thin,] = current$"gamma"
              chain$"delta"[k/thin,] = current$"delta"
              chain$"yearTrend"[k/thin,] = current$"yearTrend"
              chain$"sigmaSq.yearTrend"[k/thin] = current$"sigmaSq.yearTrend"
              
              print(k/thin)
          }
      }

      save.image(file = paste("./Simulations/Ybias", percentBias , "-", i, ".RData", sep = "") )
  }
  
#+END_SRC

* Shell Script For Running in parallel on Cluster
#+BEGIN_SRC shell :tangle runDrift.job
  
  #PBS -l nodes=1:ppn=1

  #PBS -l walltime=20:00:00

  #PBS -l pmem=6gb

  #PBS -j oe

  date
  Rscript "/storage/home/jlp592/work/UkraineWithYearEffect/drift.r" $DRIFT 5 5000
  
#+END_SRC

#+BEGIN_SRC shell :tangle runYBias.job

  #PBS -l nodes=1:ppn=1

  #PBS -l walltime=20:00:00

  #PBS -l pmem=6gb

  #PBS -j oe

  date
  Rscript "/storage/home/jlp592/work/UkraineWithYearEffect/ybias.r" $PBIAS 5 5000
  
#+END_SRC

* Submit Jobs

#+BEGIN_SRC shell :tangle submitSims.sh

  export DRIFT=".0"
  qsub ./runDrift.job -A open -v DRIFT
  
  export DRIFT=".05"
  qsub ./runDrift.job -A open -v DRIFT

  export DRIFT=".1"
  qsub ./runDrift.job -A open -v DRIFT

  export DRIFT=".2"
  qsub ./runDrift.job -A open -v DRIFT

  export DRIFT=".4"
  qsub ./runDrift.job -A open -v DRIFT

  export DRIFT=".8"
  qsub ./runDrift.job -A open -v DRIFT

  export PBIAS="0"
  qsub ./runYBias.job -A open -v PBIAS
  
  export PBIAS=".01"
  qsub ./runYBias.job -A open -v PBIAS
  
  export PBIAS=".03"
  qsub ./runYBias.job -A open -v PBIAS

  export PBIAS=".1"
  qsub ./runYBias.job -A open -v PBIAS

  export PBIAS=".3"
  qsub ./runYBias.job -A open -v PBIAS

  export PBIAS=".9"
  qsub ./runYBias.job -A open -v PBIAS
  
#+END_SRC

* Generate Plots

#+BEGIN_SRC R :tangle simPlots.r

  drifts = c(.0, .05, .1, .2, .4, .8)

  piEstimate = array(NA, dim = c(6, 5, 27, 9) )
  piEstimate.u = array(NA, dim = c(6, 5, 27, 9) )
  piEstimate.l = array(NA, dim = c(6, 5, 27, 9) )

  piEstimate.mean = array(NA, dim = c(6, 5, 9) )
  piEstimate.mean.u = array(NA, dim = c(6, 5, 9) )
  piEstimate.mean.l = array(NA, dim = c(6, 5, 9) )
    
  thetaEstimate = array(NA, dim = c(6, 5) )
  thetaEstimate.u = array(NA, dim = c(6, 5) )
  thetaEstimate.l = array(NA, dim = c(6, 5) )

  muEstimate = array(NA, dim = c(6, 5) )
  muEstimate.u = array(NA, dim = c(6, 5) )
  muEstimate.l = array(NA, dim = c(6, 5) )
  
  for(drift in drifts)
  {
      for(i in 1:5)
      {
          load(file = paste("./Simulations/", drift , "-", i, ".RData", sep = "") )
          
          piEstimate[drift == drifts, i, ,] = colMeans(logit(chain$pi))
          piEstimate.u[drift == drifts, i, ,] = apply(logit(chain$pi), MARGIN = c(2,3), FUN = quantile, probs = c(.975))
          piEstimate.l[drift == drifts, i, ,] = apply(logit(chain$pi), MARGIN = c(2,3), FUN = quantile, probs = c(.025))

          piEstimate.mean[drift == drifts, i ,] =  colMeans(colMeans(logit(chain$pi)))
          piEstimate.mean.u[drift == drifts, i, ] = apply(apply(logit(chain$pi), MARGIN = c(1,3), FUN = mean), FUN = quantile, probs = c(.975), MARGIN = 2)
          piEstimate.mean.l[drift == drifts, i, ] = apply(apply(logit(chain$pi), MARGIN = c(1,3), FUN = mean), FUN = quantile, probs = c(.025), MARGIN = 2)
          
          thetaEstimate[drift == drifts, i] = mean(chain$theta)
          thetaEstimate.l[drift == drifts, i] = quantile(chain$theta, probs = c(.025) )
          thetaEstimate.u[drift == drifts, i] = quantile(chain$theta, probs = c(.975) )
          
          muEstimate[drift == drifts, i] = mean(chain$mu)
          muEstimate.l[drift == drifts, i] = quantile(chain$mu, probs = c(.025) )
          muEstimate.u[drift == drifts, i] = quantile(chain$mu, probs = c(.975) )

      }
      
  }

  library(plotrix)

  year = matrix(0:8, nrow = 6, ncol = 9, byrow = TRUE)
  driftMat = matrix(drifts, nrow = 6, ncol = 9, byrow = FALSE)
  driftMat*year

  thetaMat = .9 + driftMat*year

  meanTheta = rowMeans(thetaMat)

  postscript(file = "./plots/thetaByDrift.eps", width = 5, height = 5)
  par(mar = c(4.5,3.8,1,1))
  plotCI(drifts, y = thetaEstimate[,1],
         ui = thetaEstimate.u[,1],
         li = thetaEstimate.l[,1],
         xlab = "Yearly Drift in Average Proportion Estimate Bias Parameter",
         ylab = "Estimated Proportion Estimate Bias Parameter"
         )
    plotCI(drifts + .02, y = thetaEstimate[,2],
         ui = thetaEstimate.u[,2],
         li = thetaEstimate.l[,2],
         add = TRUE
         )
  abline(a = .9, b = 4)
  dev.off()
  
  postscript(file = "./plots/muByDrift.eps")
  plotCI(drifts, y = muEstimate[,1],
         ui = muEstimate.u[,1],
         li = muEstimate.l[,1],
         xlab = "Yearly Drift in Average Proportion Estimate Bias Parameter",
         ylab = "Estimated NSU Estimate Bias Parameter"
         )
    plotCI(drifts + .02, y = muEstimate[,2],
         ui = muEstimate.u[,2],
         li = muEstimate.l[,2],
         add = TRUE
         )
  abline(h = 0)
  dev.off()


  postscript(file = "./plots/prevalenceDrift.eps", width = 5, height = 5)
  par(mar = c(4.5,3.8,1,1))
  plotCI(drifts, y = piEstimate.mean[,1,1],
         ui = piEstimate.mean.u[,1,1],
         li = piEstimate.mean.l[,1,1],
         ylim = c(logit(.04), logit(.057)),
         xlab = "Yearly Drift in Average Proportion Estimate Bias Parameter",
         ylab = "Estimated Mean Logit Prevalence (First Year)")
  plotCI(drifts + .02, y = piEstimate.mean[,2,1],
         ui = piEstimate.mean.u[,2,1],
         li = piEstimate.mean.l[,2,1],
         add = TRUE
         )
  abline(h = logit(.05))
  dev.off()

  year = matrix(1:9, nrow = 5, ncol = 9, byrow = TRUE)
  
  postscript(file = "./plots/prevalenceYear.eps", width = 960)
  par(mfrow = c(1,2))
  plot(year, y = piEstimate.mean[1,,],
         ylim = c(logit(.04), logit(.057)),
         xlab = "Year",
       ylab = "Estimated Mean Logit Prevalence (First Year)",
       main = "0 Drift in Bias Parameter Per Year")
  abline(h=logit(.05))
  plot(year, y = piEstimate.mean[6,,],
         ylim = c(logit(.04), logit(.057)),
         xlab = "Year",
       ylab = "Estimated Mean Logit Prevalence (First Year)",
       main = ".8 Drift in Bias Parameter Per Year")
  abline(h=logit(.05))
  dev.off()
      
  percents = c(0, .01, .03, .1, .3, .9)

  piEstimate = array(NA, dim = c(6, 5, 27, 9) )
  piEstimate.u = array(NA, dim = c(6, 5, 27, 9) )
  piEstimate.l = array(NA, dim = c(6, 5, 27, 9) )

  piEstimate.mean = array(NA, dim = c(6, 5, 9) )
  piEstimate.mean.u = array(NA, dim = c(6, 5, 9) )
  piEstimate.mean.l = array(NA, dim = c(6, 5, 9) )
    
  thetaEstimate = array(NA, dim = c(6, 5) )
  thetaEstimate.u = array(NA, dim = c(6, 5) )
  thetaEstimate.l = array(NA, dim = c(6, 5) )
  
  for(percentBias in percents)
  {
      for(i in 1:5)
      {
          load(file = paste("./Simulations/Ybias", percentBias , "-", i, ".RData", sep = "") )          
          
          piEstimate[percentBias == percents, i, ,] = colMeans(logit(chain$pi))
          piEstimate.u[percentBias == percents, i, ,] = apply(logit(chain$pi), MARGIN = c(2,3), FUN = quantile, probs = c(.975))
          piEstimate.l[percentBias == percents, i, ,] = apply(logit(chain$pi), MARGIN = c(2,3), FUN = quantile, probs = c(.975))

          piEstimate.mean[percentBias == percents, i ,] =  colMeans(colMeans(logit(chain$pi)))
          piEstimate.mean.u[percentBias == percents, i, ] = quantile(apply(logit(chain$pi), MARGIN = c(1,3), FUN = mean), probs = c(.975))
          piEstimate.mean.l[percentBias == percents, i, ] = quantile(apply(logit(chain$pi), MARGIN = c(1,3), FUN = mean), probs = c(.025))
          
          thetaEstimate[percentBias == percents, i] = mean(chain$theta)
          thetaEstimate.l[percentBias == percents, i] = quantile(chain$theta, probs = c(.025) )
          thetaEstimate.u[percentBias == percents, i] = quantile(chain$theta, probs = c(.975) )

      }
      
  }

  postscript(file = "./plots/thetaByPercent.eps", width = 5, height = 5)
  par(mar = c(4.5,3.8,.1,.1))
  plot(matrix(percents, nrow = 6, ncol =5, byrow = FALSE), y = thetaEstimate,
       xlab = "Percent Error in Y",
         ylab = "Estimated Proportion Bias Parameter",
         )
  abline(h = 0)
  dev.off()
  
  postscript(file = "./plots/muByPercent.eps")
  plot(matrix(percents, nrow = 6, ncol =5, byrow = FALSE), y = muEstimate,
       xlab = "Percent Error in Y",
         ylab = "Estimated NSU Estimate Bias Parameter",
         )
  abline(h = 0)
  dev.off()
  
  postscript(file = "./plots/prevalencePercent.eps", width = 5, height = 5)
  par(mar = c(4.5,3.8,.1,.1))
  plotCI(1:6, y = piEstimate.mean[,1,1],
         ui = piEstimate.mean.u[,1,1],
         li = piEstimate.mean.l[,1,1],
         ylim = c(-3.3, -2.6),
         xlab = "Percent Error in Y",
         ylab = "Estimated Mean Logit Prevalence (First Year)",
         axes = FALSE)
  axis(1, at = 1:6, labels = percents)
  axis(2)
  box()
  plotCI(1:6 + .1, y = piEstimate.mean[,3,1],
         ui = piEstimate.mean.u[,3,1],
         li = piEstimate.mean.l[,3,1],
         add = TRUE
         )
  abline(h = logit(.05))
  dev.off()

  
#+END_SRC

* Generate Plots for Averaging

#+BEGIN_SRC R :tangle simPlots.r

  drifts = c(.0, .05, .1, .2, .4, .8)
  
  piEstimate.mean = array(NA, dim = c(6, 5, 9) )
  
  for(drift in drifts)
  {
      for(i in 1:5)
      {
          load(file = paste("./Simulations/", drift , "-", i, ".RData", sep = "") )

          Nhat = array(NA, dim = c(27,8,9) )
          Nhat[,-8,] = data$Y/data$phat 
          Nhat[,8,] = data$NSU

          Nhat = apply(Nhat, MARGIN = c(1,3), FUN = median, na.rm = TRUE)

          piEstimate.mean[drift == drifts, i, ] = mean(Nhat/data$R, na.rm = TRUE)
          
      }
      
  }

  year = matrix(0:8, nrow = 6, ncol = 9, byrow = TRUE)
  driftMat = matrix(drifts, nrow = 6, ncol = 9, byrow = FALSE)
  driftMat*year

  thetaMat = .9 + driftMat*year

  meanTheta = rowMeans(thetaMat)

  postscript(file = "./plots/prevalenceDrift2.eps", width = 5, height = 5)
  par(mar = c(4.5,3.8,1,1))
  plot( drifts,logit(piEstimate.mean[,1,1]),
       xlab = "Yearly Drift in Average Proportion Estimate Bias Parameter",
       ylab = "Estimated Mean Logit Prevalence (First Year)")
  points(drifts, y = logit(piEstimate.mean[,2,1]))
  abline(h = .05)
  dev.off()
  
#+END_SRC
